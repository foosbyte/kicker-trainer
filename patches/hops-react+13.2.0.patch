diff --git a/node_modules/hops-react/render/mixin.browser.js b/node_modules/hops-react/render/mixin.browser.js
index aa12b49..ddcc712 100644
--- a/node_modules/hops-react/render/mixin.browser.js
+++ b/node_modules/hops-react/render/mixin.browser.js
@@ -26,9 +26,12 @@ class ReactMixin extends Mixin {
         this.fetchData({}, element).then(() => {
           const mountpoint = document.querySelector('[data-mountpoint]');
           const isMounted = mountpoint.hasAttribute('data-mounted');
+          const { disableSSR } = this.getServerData();
 
-          if (isMounted) {
-            unmountComponentAtNode(mountpoint);
+          if (isMounted || disableSSR) {
+            if (!disableSSR) {
+              unmountComponentAtNode(mountpoint);
+            }
             render(element, mountpoint);
           } else {
             hydrate(element, mountpoint);
diff --git a/node_modules/hops-react/render/mixin.core.js b/node_modules/hops-react/render/mixin.core.js
new file mode 100644
index 0000000..0bc3836
--- /dev/null
+++ b/node_modules/hops-react/render/mixin.core.js
@@ -0,0 +1,25 @@
+'use strict';
+
+const { Mixin } = require('hops-mixin');
+
+let count = 0;
+
+class ReactRenderCoreMixin extends Mixin {
+  configureServer(app, middlewares, mode) {
+    if (mode === 'serve') {
+      middlewares.preroutes.push((req, res, next) => {
+        // todo: this middleware should check the event loop delay and set
+        // `disableSSR` to true if it exceeds the threshold
+        // note: we should give priority to crawlers in order to not impact SEO
+        // or social sharing previews
+        count += 1;
+        if (req.query.disableSSR || req.query.fakeCircuitBreaker && count % 2 === 0) {
+          res.locals.disableSSR = true;
+        }
+        next();
+      });
+    }
+  }
+}
+
+module.exports = ReactRenderCoreMixin;
\ No newline at end of file
diff --git a/node_modules/hops-react/render/mixin.server.js b/node_modules/hops-react/render/mixin.server.js
index 8740f81..27a0a32 100644
--- a/node_modules/hops-react/render/mixin.server.js
+++ b/node_modules/hops-react/render/mixin.server.js
@@ -3,6 +3,8 @@
 const { isValidElement } = require('react');
 const isPlainObject = require('is-plain-obj');
 const { override: overrideSync, async } = require('mixinable');
+const path = require('path');
+const Piscina = require('piscina');
 const { Mixin } = require('hops-mixin');
 const { internal: bootstrap } = require('hops-bootstrap');
 const renderToFragments = require('../lib/fragments');
@@ -13,20 +15,47 @@ const template = require('../lib/template');
 const { compose, parallel, pipe, override: overrideAsync } = async;
 const { validate, invariant } = bootstrap;
 
+// todo: this is ugly, we could use the fileName argument of `runTask`,
+// but we still need to be able to get stats passed into `workerData`
+let piscina = undefined;
+function getPiscina(filename, stats) {
+  if (piscina) {
+    return piscina;
+  }
+  piscina = new Piscina({
+    filename,
+    idleTimeout: 5000,
+    concurrentTasksPerWorker: 2,
+    workerData: { locals: { stats } },
+  });
+  return piscina;
+}
+
 class ReactMixin extends Mixin {
   constructor(config, element, options) {
     super(config, options);
     this.element = element;
+    this.stats = undefined;
+    this.disableSSR = false;
   }
 
   bootstrap(req, res) {
     this.stats = res.locals.stats;
+    // note: res.locals.disableSSR should be set by our circuit breaker
+    this.disableSSR = res.locals.disableSSR;
   }
 
   renderToFragments(element) {
     return renderToFragments(element);
   }
 
+  getTemplateData(data) {
+    return {
+      ...data,
+      disableSSR: this.disableSSR,
+    };
+  }
+
   renderTemplate(fragments, { modules }) {
     const assets = getAssets(this.stats, modules);
     const resourceHints = getResourceHints(this.stats);
@@ -41,17 +70,58 @@ class ReactMixin extends Mixin {
   }
 
   render(req, res, next) {
-    Promise.resolve()
-      .then(() => this.bootstrap(req, res))
-      .then(() => this.enhanceElement(this.element))
-      .then((element) =>
-        this.fetchData({}, element).then(() => this.renderToFragments(element))
-      )
+    const workerFile = path.join(this.config.serverDir, this.config.serverFile);
+
+    if (req.query.useWorkerPool && process.env.NODE_ENV === 'production' && !Piscina.isWorkerThread) {
+      const fakeRequest = {
+        url: req.url,
+        method: req.method,
+        params: req.params,
+        query: req.query,
+        headers: req.headers,
+        cookies: req.cookies,
+        app: true,
+      };
+
+      return getPiscina(workerFile, res.locals.stats)
+        .runTask(fakeRequest)
+        .then((data) => {
+          if (data.miss) {
+            next(data.error);
+          } else {
+            if (data.headers) {
+              res.set(data.headers);
+            }
+            if (data.url) {
+              res.redirect(data.status || 301, data.url);
+            } else {
+              res.status(data.status || 200);
+              res.send(data.html);
+            }
+          }
+        });
+    }
+
+    let waiting = this.bootstrap(req, res);
+
+    if (this.disableSSR) {
+      waiting = waiting.then(() => {
+        return {};
+      });
+    } else {
+      waiting = waiting
+        .then(() => this.enhanceElement(this.element))
+        .then((element) => {
+          return this.fetchData({}, element).then(() => this.renderToFragments(element));
+        });
+    }
+
+    return waiting
       .then((fragments) => {
         // note: res.locals.helmetContext is set by the ReactHelmetMixin
         Object.assign(
           fragments,
-          Object.entries(res.locals.helmetContext.helmet).reduce(
+          Object.entries(res.locals.helmetContext.helmet || {}).reduce(
             (result, [key, value]) => ({ ...result, [key]: value.toString() }),
             { headPrefix: '', headSuffix: '' }
           )
